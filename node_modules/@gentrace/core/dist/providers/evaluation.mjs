import { globalGentraceApi, GENTRACE_RUN_NAME, GENTRACE_BRANCH, GENTRACE_COMMIT } from './init.mjs';
import { getProcessEnv, incrementTestCounter, decrementTestCounter } from './utils.mjs';

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Retrieves test cases for a given pipeline ID from the Gentrace API
 * @async
 * @param {string} pipelineSlug - The pipeline slug
 * @throws {Error} Throws an error if the SDK is not initialized. Call init() first.
 * @returns {Promise<Array<TestCase>>} A Promise that resolves with an array of test cases.
 */
const getTestCases = (pipelineSlug) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    let pipelineId = pipelineSlug;
    if (!isUUID(pipelineSlug)) {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        pipelineId = matchingPipeline.id;
    }
    const response = yield globalGentraceApi.testCaseGet(pipelineId);
    const testCases = (_a = response.data.testCases) !== null && _a !== void 0 ? _a : [];
    return testCases;
});
function isTestCaseSingle(response) {
    return response.caseId !== undefined;
}
/**
 * Creates a single test case for a given pipeline ID from the Gentrace API
 *
 * @async
 * @param {CreateSingleTestCase} payload - New test case payload
 * @throws {Error} Throws an error if the SDK is not initialized. Call init() first.
 * @returns {Promise<string>} A Promise that resolves to the created case ID
 */
const createTestCase = (payload) => __awaiter(void 0, void 0, void 0, function* () {
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const { pipelineSlug } = payload;
    if (!isUUID(pipelineSlug)) {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        matchingPipeline.id;
    }
    const response = yield globalGentraceApi.testCasePost(payload);
    const data = response.data;
    if (!isTestCaseSingle(data)) {
        throw new Error("Expected a single test case to be created.");
    }
    return data.caseId;
});
/**
 * Creates multiple test cases for a given pipeline ID from the Gentrace API
 *
 * @async
 * @param {CreateMultipleTestCases} payload - New test case payloads
 * @throws {Error} Throws an error if the SDK is not initialized. Call init() first.
 * @returns {Promise<stringl>} A Promise that resolves to the number of test cases successfully created
 */
const createTestCases = (payload) => __awaiter(void 0, void 0, void 0, function* () {
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const { pipelineSlug } = payload;
    if (!isUUID(pipelineSlug)) {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        matchingPipeline.id;
    }
    const response = yield globalGentraceApi.testCasePost(payload);
    const data = response.data;
    if (isTestCaseSingle(data)) {
        throw new Error("Expected multiple test cases to be created.");
    }
    return data.creationCount;
});
const updateTestCase = (payload) => __awaiter(void 0, void 0, void 0, function* () {
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const { id } = payload;
    if (!isUUID(id)) {
        throw new Error("Expected a valid test case ID.");
    }
    const response = yield globalGentraceApi.testCasePatch(payload);
    const data = response.data;
    return data.caseId;
});
const constructSubmissionPayload = (pipelineId, testRuns) => {
    const body = {
        pipelineId,
        testRuns,
    };
    if (GENTRACE_RUN_NAME) {
        body.name = GENTRACE_RUN_NAME;
    }
    if (GENTRACE_BRANCH || getProcessEnv("GENTRACE_BRANCH")) {
        body.branch =
            GENTRACE_BRANCH.length > 0
                ? GENTRACE_BRANCH
                : getProcessEnv("GENTRACE_BRANCH");
    }
    if (GENTRACE_COMMIT || getProcessEnv("GENTRACE_COMMIT")) {
        body.commit =
            GENTRACE_COMMIT.length > 0
                ? GENTRACE_COMMIT
                : getProcessEnv("GENTRACE_COMMIT");
    }
    body.collectionMethod = "runner";
    return body;
};
function isUUID(str) {
    const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;
    return uuidPattern.test(str);
}
/**
 * Submits test results by creating TestResult objects from given test cases and corresponding outputs.
 * To use a Gentrace runner to capture intermediate steps, use {@link runTest} instead.
 *
 * @async
 * @function
 * @param {string} pipelineSlug - The slug of the pipeline
 * @param {TestCase[]} testCases - An array of TestCase objects.
 * @param {string[]} outputs - An array of outputs corresponding to each TestCase.
 *
 * @throws {Error} Will throw an error if the Gentrace API key is not initialized. Also, will throw an error if the number of test cases
 *  does not match the number of outputs.
 *
 * @returns {Promise<TestRunPost200Response>} The response data from the Gentrace API's testRunPost method.
 */
const submitTestResult = (pipelineSlug, testCases, outputsList) => __awaiter(void 0, void 0, void 0, function* () {
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    if (testCases.length !== outputsList.length) {
        throw new Error("The number of test cases must be equal to the number of outputs.");
    }
    const testRuns = testCases.map((testCase, index) => {
        const run = {
            caseId: testCase.id,
            inputs: testCase.inputs,
            outputs: outputsList[index],
        };
        return run;
    });
    const body = {
        pipelineSlug,
        testRuns: testRuns,
    };
    if (GENTRACE_RUN_NAME) {
        body.name = GENTRACE_RUN_NAME;
    }
    if (GENTRACE_BRANCH || getProcessEnv("GENTRACE_BRANCH")) {
        body.branch =
            GENTRACE_BRANCH.length > 0
                ? GENTRACE_BRANCH
                : getProcessEnv("GENTRACE_BRANCH");
    }
    if (GENTRACE_COMMIT || getProcessEnv("GENTRACE_COMMIT")) {
        body.commit =
            GENTRACE_COMMIT.length > 0
                ? GENTRACE_COMMIT
                : getProcessEnv("GENTRACE_COMMIT");
    }
    const response = yield globalGentraceApi.testResultSimplePost(body);
    return response.data;
});
/**
 * Retrieves pipelines from the Gentrace API.
 * @async
 * @param {PipelineParams} [params] - Optional parameters to filter the pipelines.
 * @returns {Promise<Array<Pipeline>>} - A promise that resolves to an array of pipelines.
 * @throws {Error} - Throws an error if the Gentrace API key is not initialized.
 */
const getPipelines = (params) => __awaiter(void 0, void 0, void 0, function* () {
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const label = (params !== null && params !== void 0 ? params : {}).label;
    const slug = (params !== null && params !== void 0 ? params : {}).slug;
    const parameters = [label, slug];
    const response = yield globalGentraceApi.pipelinesGet(...parameters);
    return response.data.pipelines;
});
/**
 * Runs a test for a specific pipeline.
 *
 * @param {string} pipelineSlug - The slug of the pipeline.
 * @param {(testCase: TestCase) => Promise<PipelineRun>} handler - The handler function that runs the test case and returns a promise with a PipelineRun.
 * @returns {Promise<TestRun>} - A promise that resolves to the test result.
 * @throws {Error} - Throws an error if the specified pipeline cannot be found.
 */
const runTest = (pipelineSlug, handler) => __awaiter(void 0, void 0, void 0, function* () {
    incrementTestCounter();
    try {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        const testCases = yield getTestCases(matchingPipeline.id);
        const testRuns = [];
        for (const testCase of testCases) {
            const [, pipelineRun] = yield handler(testCase);
            const testRun = {
                caseId: testCase.id,
                stepRuns: pipelineRun.stepRuns.map((stepRun) => ({
                    modelParams: stepRun.modelParams,
                    invocation: stepRun.invocation,
                    inputs: stepRun.inputs,
                    outputs: stepRun.outputs,
                    providerName: stepRun.provider,
                    elapsedTime: stepRun.elapsedTime,
                    startTime: stepRun.startTime,
                    endTime: stepRun.endTime,
                    context: Object.assign(Object.assign({}, pipelineRun.context), stepRun.context),
                })),
            };
            if (pipelineRun.getId()) {
                testRun.id = pipelineRun.getId();
            }
            testRuns.push(testRun);
        }
        if (!globalGentraceApi) {
            throw new Error("Gentrace API key not initialized. Call init() first.");
        }
        const body = constructSubmissionPayload(matchingPipeline.id, testRuns);
        const response = yield globalGentraceApi.testResultPost(body);
        return response.data;
    }
    catch (e) {
        throw e;
    }
    finally {
        // Imperative that we decrement the test counter regardless of whether the function
        // runs into an error or not.
        decrementTestCounter();
    }
});

export { constructSubmissionPayload, createTestCase, createTestCases, getPipelines, getTestCases, runTest, submitTestResult, updateTestCase };
//# sourceMappingURL=evaluation.mjs.map
